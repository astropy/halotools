# -*- coding: utf-8 -*-
"""
Module storing the various factories used to build galaxy-halo models. 
"""

__all__ = ['ModelFactory', 'SubhaloModelFactory', 'HodModelFactory']
__author__ = ['Andrew Hearin']

import numpy as np
from copy import copy
from functools import partial

from astropy.extern import six
from abc import ABCMeta, abstractmethod, abstractproperty

from . import model_helpers
from . import model_defaults 
from . import mock_factories

from ..sim_manager.supported_sims import HaloCatalog
from ..sim_manager import sim_defaults

from ..sim_manager.generate_random_sim import FakeSim
from ..utils.array_utils import custom_len

from ..custom_exceptions import *
from warnings import warn 

@six.add_metaclass(ABCMeta)
class ModelFactory(object):
    """ Abstract container class used to build 
    any composite model of the galaxy-halo connection. 
    """

    def __init__(self, input_model_blueprint, **kwargs):
        """
        Parameters
        ----------
        input_model_blueprint : dict 
            Blueprint providing instructions for how to build the composite 
            model from a set of components. 

        galaxy_selection_func : function object, optional  
            Function object that imposes a cut on the mock galaxies. 
            Function should take an Astropy table as a positional argument, 
            and return a boolean numpy array that will be 
            treated as a mask over the rows of the table. If not None, 
            the mask defined by ``galaxy_selection_func`` will be applied to the 
            ``halo_table`` after the table is generated by the `populate_mock` method. 
            Default is None.  
        """

        # Bind the model-building instructions to the composite model
        self._input_model_blueprint = input_model_blueprint

        if 'galaxy_selection_func' in kwargs.keys():
            self.galaxy_selection_func = kwargs['galaxy_selection_func']

    def populate_mock(self, **kwargs):
        """ Method used to populate a simulation using the model. 

        After calling this method, ``self`` will have a new ``mock`` attribute, 
        which has a ``halo_table`` bound to it containing the Monte Carlo 
        realization of the model. 

        Parameters 
        ----------
        snapshot : object, optional 
            Class instance of `~halotools.sim_manager.HaloCatalog`. 
            This object contains the halo catalog and its metadata.  

        simname : string, optional
            Nickname of the simulation. Currently supported simulations are 
            Bolshoi  (simname = ``bolshoi``), Consuelo (simname = ``consuelo``), 
            MultiDark (simname = ``multidark``), and Bolshoi-Planck (simname = ``bolplanck``). 
            Default is set in `~halotools.sim_manager.sim_defaults`. 

        halo_finder : string, optional
            Nickname of the halo-finder, e.g. ``rockstar`` or ``bdm``. 
            Default is set in `~halotools.sim_manager.sim_defaults`. 

        redshift : float, optional
            Redshift of the desired catalog. 
            Default is set in `~halotools.sim_manager.sim_defaults`. 

        """
        inconsistent_redshift_error_msg = ("Inconsistency between the model redshift = %.2f "
            "and the snapshot redshift = %.2f.\n"
            "You should instantiate a new model object if you wish to switch halo catalogs.")
        inconsistent_simname_error_msg = ("Inconsistency between the simname "
            "already bound to the existing mock = ``%s`` "
            "and the simname passed as a keyword argument = ``%s``.\n"
            "You should instantiate a new model object if you wish to switch halo catalogs.")
        inconsistent_halo_finder_error_msg = ("Inconsistency between the halo-finder "
            "already bound to the existing mock = ``%s`` "
            "and the halo-finder passed as a keyword argument = ``%s``.\n"
            "You should instantiate a new model object if you wish to switch halo catalogs.")


        def test_consistency_with_existing_mock(**kwargs):
            if 'redshift' in kwargs:
                redshift = kwargs['redshift']
            else:
                redshift = sim_defaults.default_redshift
            if abs(redshift - self.mock.snapshot.redshift) > 0.05:
                raise HalotoolsError(inconsistent_redshift_error_msg % (redshift, self.mock.snapshot.redshift))

            if 'simname' in kwargs:
                simname = kwargs['simname']
            else:
                simname = sim_defaults.default_simname
            if simname != self.mock.snapshot.simname:
                raise HalotoolsError(inconsistent_simname_error_msg)

            if 'halo_finder' in kwargs:
                halo_finder = kwargs['halo_finder']
            else:
                halo_finder = sim_defaults.default_halo_finder
            if halo_finder != self.mock.snapshot.halo_finder:
                raise HalotoolsError(inconsistent_halo_finder_error_msg)

        if hasattr(self, 'mock'):
            test_consistency_with_existing_mock(**kwargs)
        else:
            if 'snapshot' in kwargs.keys():
                snapshot = kwargs['snapshot']
                del kwargs['snapshot'] # otherwise the call to mock_factories below has multiple snapshot arguments
            else:
                snapshot = HaloCatalog(**kwargs)

            if hasattr(self, 'redshift'):
                if abs(self.redshift - snapshot.redshift) > 0.05:
                    raise HalotoolsError("Inconsistency between the model redshift = %.2f" 
                        " and the snapshot redshift = %.2f" % (self.redshift, snapshot.redshift))

            mock_factory = self.mock_factory 
            self.mock = mock_factory(snapshot=snapshot, model=self, populate=False)


        self.mock.populate()

    def compute_average_galaxy_clustering(self, num_iterations=5, summary_statistic = 'median', **kwargs):
        """
        Method repeatedly populates a simulation with a mock galaxy catalog, computes the clustering 
        signal of each Monte Carlo realization, and returns a summary statistic of the clustering 
        such as the median computed from the collection of clustering measurements. 

        Parameters 
        ----------
        num_iterations : int, optional 
            Number of Monte Carlo realizations to use to estimate the clustering signal. 
            Default is 5.

        summary_statistic : string, optional 
            String specifying the method used to estimate the clustering signal from the 
            collection of Monte Carlo realizations. Options are ``median`` and ``mean``. 
            Default is ``median``. 

        simname : string, optional 
            Nickname of the simulation into which mock galaxies will be populated. 
            Currently supported simulations are 
            Bolshoi  (simname = ``bolshoi``), Consuelo (simname = ``consuelo``), 
            MultiDark (simname = ``multidark``), and Bolshoi-Planck (simname = ``bolplanck``). 
            Default is set in `~halotools.sim_manager.sim_defaults`. 

        halo_finder : string, optional  
            Nickname of the halo-finder of the snapshot into which mock galaxies 
            will be populated, e.g., `rockstar` or `bdm`. 
            Default is set in `~halotools.sim_manager.sim_defaults`. 

        desired_redshift : float, optional
            Redshift of the desired snapshot into which mock galaxies will be populated. 
            Default is set in `~halotools.sim_manager.sim_defaults`. 

        variable_galaxy_mask : scalar, optional 
            Any value used to construct a mask to select a sub-population 
            of mock galaxies. See examples below. 

        mask_function : array, optional 
            Function object returning a masking array when operating on the galaxy_table. 
            More flexible than the simpler ``variable_galaxy_mask`` option because ``mask_function``
            allows for the possibility of multiple simultaneous cuts. See examples below. 

        include_crosscorr : bool, optional 
            Only for simultaneous use with a ``variable_galaxy_mask``-determined mask. 
            If ``include_crosscorr`` is set to False (the default option), method will return 
            the auto-correlation function of the subsample of galaxies determined by 
            the input ``variable_galaxy_mask``. If ``include_crosscorr`` is True, 
            method will return the auto-correlation of the subsample, 
            the cross-correlation of the subsample and the complementary subsample, 
            and the the auto-correlation of the complementary subsample, in that order. 
            See examples below. 

        rbins : array, optional 
            Bins in which the correlation function will be calculated. 
            Default is set in `~halotools.empirical_models.model_defaults` module. 

        Returns 
        --------
        rbin_centers : array 
            Midpoint of the bins used in the correlation function calculation 

        correlation_func : array 
            If not using any mask (the default option), method returns the 
            correlation function of the full mock galaxy catalog. 

            If using a mask, and if ``include_crosscorr`` is False (the default option), 
            method returns the correlation function of the subsample of galaxies determined by 
            the input mask. 

            If using a mask, and if ``include_crosscorr`` is True, 
            method will return the auto-correlation of the subsample, 
            the cross-correlation of the subsample and the complementary subsample, 
            and the the auto-correlation of the complementary subsample, in that order. 
            See the example below. 

        Examples 
        ---------
        The simplest use-case of the `compute_average_galaxy_clustering` function 
        is just to call the function with no arguments. This will generate a sequence 
        of Monte Carlo realizations of your model into the default snapshot, 
        calculate the two-point correlation function of all galaxies in your mock, 
        and return the median clustering strength in each radial bin: 

        >>> model = Leauthaud11() # doctest: +SKIP 
        >>> r, clustering = model.compute_average_galaxy_clustering() # doctest: +SKIP 

        To control how which simulation is used, you use the same syntax you use to load 
        a `~halotools.sim_manager.HaloCatalog` into memory from your cache directory: 

        >>> r, clustering = model.compute_average_galaxy_clustering(simname = 'multidark', desired_redshift=1) # doctest: +SKIP 

        You can control the number of mock catalogs that are generated via: 

        >>> r, clustering = model.compute_average_galaxy_clustering(num_iterations = 10) # doctest: +SKIP 

        You may wish to focus on the clustering signal for a specific subpopulation. To do this, 
        you have two options. First, you can use the ``variable_galaxy_mask`` mechanism: 

        >>> r, clustering = model.compute_average_galaxy_clustering(gal_type = 'centrals') # doctest: +SKIP 

        With the ``variable_galaxy_mask`` mechanism, you are free to use any column of your galaxy_table 
        as a keyword argument. If you couple this function call with the ``include_crosscorr`` 
        keyword argument, the function will also return all auto- and cross-correlations of the subset 
        and its complement:

        >>> r, cen_cen, cen_sat, sat_sat = model.compute_average_galaxy_clustering(gal_type = 'centrals', include_crosscorr = True) # doctest: +SKIP 

        Your second option is to use the ``mask_function`` option. 
        For example, suppose we wish to study the clustering of satellite galaxies 
        residing in cluster-mass halos:

        >>> def my_masking_function(table): # doctest: +SKIP
        >>>     result = (table['halo_mvir'] > 1e14) & (table['gal_type'] == 'satellites') # doctest: +SKIP
        >>>     return result # doctest: +SKIP
        >>> r, cluster_sat_clustering = model.compute_average_galaxy_clustering(mask_function = my_masking_function) # doctest: +SKIP 

        Notes 
        -----
        The `compute_average_galaxy_clustering` method bound to mock instances is just a convenience wrapper 
        around the `~halotools.mock_observables.clustering.tpcf` function. If you wish for greater 
        control over how your galaxy clustering signal is estimated, 
        see the `~halotools.mock_observables.clustering.tpcf` documentation. 
        """
        if summary_statistic == 'mean':
            summary_func = np.mean 
        else:
            summary_func = np.median


        halocat_kwargs = {}
        if 'simname' in kwargs:
            halocat_kwargs['simname'] = kwargs['simname']
        if 'desired_redshift' in kwargs:
            halocat_kwargs['redshift'] = kwargs['desired_redshift']
        if 'halo_finder' in kwargs:
            halocat_kwargs['halo_finder'] = kwargs['halo_finder']

        snapshot = HaloCatalog(preload_halo_table = True, **halocat_kwargs)

        if 'rbins' in kwargs:
            rbins = kwargs['rbins']
        else:
            rbins = model_defaults.default_rbins

        if 'include_crosscorr' in kwargs.keys():
            include_crosscorr = kwargs['include_crosscorr']
        else:
            include_crosscorr = False

        if include_crosscorr is True:

            xi_coll = np.zeros(
                (len(rbins)-1)*num_iterations*3).reshape(3, num_iterations, len(rbins)-1)

            for i in range(num_iterations):
                self.populate_mock(snapshot = snapshot)
                rbin_centers, xi_coll[0, i, :], xi_coll[1, i, :], xi_coll[2, i, :] = (
                    self.mock.compute_galaxy_clustering(**kwargs)
                    )
            xi_11 = summary_func(xi_coll[0, :], axis=0)
            xi_12 = summary_func(xi_coll[1, :], axis=0)
            xi_22 = summary_func(xi_coll[2, :], axis=0)
            return rbin_centers, xi_11, xi_12, xi_22
        else:

            xi_coll = np.zeros(
                (len(rbins)-1)*num_iterations).reshape(num_iterations, len(rbins)-1)

            for i in range(num_iterations):
                self.populate_mock(snapshot = snapshot)
                rbin_centers, xi_coll[i, :] = self.mock.compute_galaxy_clustering(**kwargs)
            xi = summary_func(xi_coll, axis=0)
            return rbin_centers, xi

    def compute_average_galaxy_matter_cross_clustering(self, num_iterations=5, 
        summary_statistic = 'median', **kwargs):
        """
        Method repeatedly populates a simulation with a mock galaxy catalog, 
        computes the galaxy-matter cross-correlation  
        signal of each Monte Carlo realization, and returns a summary statistic of the clustering 
        such as the median computed from the collection of repeated measurements. 

        Parameters 
        ----------
        num_iterations : int, optional 
            Number of Monte Carlo realizations to use to estimate the clustering signal. 
            Default is 5.

        summary_statistic : string, optional 
            String specifying the method used to estimate the clustering signal from the 
            collection of Monte Carlo realizations. Options are ``median`` and ``mean``. 
            Default is ``median``. 

        simname : string, optional 
            Nickname of the simulation into which mock galaxies will be populated. 
            Currently supported simulations are 
            Bolshoi  (simname = ``bolshoi``), Consuelo (simname = ``consuelo``), 
            MultiDark (simname = ``multidark``), and Bolshoi-Planck (simname = ``bolplanck``). 
            Default is set in `~halotools.sim_manager.sim_defaults`. 

        halo_finder : string, optional  
            Nickname of the halo-finder of the snapshot into which mock galaxies 
            will be populated, e.g., `rockstar` or `bdm`. 
            Default is set in `~halotools.sim_manager.sim_defaults`. 

        desired_redshift : float, optional
            Redshift of the desired snapshot into which mock galaxies will be populated. 
            Default is set in `~halotools.sim_manager.sim_defaults`. 

        variable_galaxy_mask : scalar, optional 
            Any value used to construct a mask to select a sub-population 
            of mock galaxies. See examples below. 

        mask_function : array, optional 
            Function object returning a masking array when operating on the galaxy_table. 
            More flexible than the simpler ``variable_galaxy_mask`` option because ``mask_function``
            allows for the possibility of multiple simultaneous cuts. See examples below. 

        include_complement : bool, optional 
            Only for simultaneous use with a ``variable_galaxy_mask``-determined mask. 
            If ``include_complement`` is set to False (the default option), method will return 
            the cross-correlation function between a random downsampling of dark matter particles 
            and the subsample of galaxies determined by 
            the input ``variable_galaxy_mask``. If ``include_complement`` is True, 
            method will also return the cross-correlation between the dark matter particles 
            and the complementary subsample. See examples below. 

        rbins : array, optional 
            Bins in which the correlation function will be calculated. 
            Default is set in `~halotools.empirical_models.model_defaults` module. 

        Examples 
        ---------
        The simplest use-case of the `compute_average_galaxy_matter_cross_clustering` function 
        is just to call the function with no arguments. This will generate a sequence 
        of Monte Carlo realizations of your model into the default snapshot, 
        calculate the cross-correlation function between dark matter 
        and all galaxies in your mock, and return the median 
        clustering strength in each radial bin: 

        >>> model = Leauthaud11() # doctest: +SKIP 
        >>> r, clustering = model.compute_average_galaxy_matter_cross_clustering() # doctest: +SKIP 

        To control how which simulation is used, you use the same syntax you use to load 
        a `~halotools.sim_manager.HaloCatalog` into memory from your cache directory: 

        >>> r, clustering = model.compute_average_galaxy_matter_cross_clustering(simname = 'multidark', desired_redshift=1) # doctest: +SKIP 

        You can control the number of mock catalogs that are generated via: 

        >>> r, clustering = model.compute_average_galaxy_matter_cross_clustering(num_iterations = 10) # doctest: +SKIP 

        You may wish to focus on the clustering signal for a specific subpopulation. To do this, 
        you have two options. First, you can use the ``variable_galaxy_mask`` mechanism: 

        >>> r, clustering = model.compute_average_galaxy_matter_cross_clustering(gal_type = 'centrals') # doctest: +SKIP 

        With the ``variable_galaxy_mask`` mechanism, you are free to use any column of your galaxy_table 
        as a keyword argument. If you couple this function call with the ``include_complement`` 
        keyword argument, the function will also return the correlation function of the complementary subset. 

        >>> r, cen_clustering, sat_clustering = model.compute_average_galaxy_matter_cross_clustering(gal_type = 'centrals', include_complement = True) # doctest: +SKIP 

        Your second option is to use the ``mask_function`` option. 
        For example, suppose we wish to study the galaxy-matter cross-correlation function of satellite galaxies 
        residing in cluster-mass halos:

        >>> def my_masking_function(table): # doctest: +SKIP
        >>>     result = (table['halo_mvir'] > 1e14) & (table['gal_type'] == 'satellites') # doctest: +SKIP
        >>>     return result # doctest: +SKIP
        >>> r, cluster_sat_clustering = model.compute_average_galaxy_matter_cross_clustering(mask_function = my_masking_function) # doctest: +SKIP 

        Returns 
        --------
        rbin_centers : array 
            Midpoint of the bins used in the correlation function calculation 

        correlation_func : array 
            If not using any mask (the default option), method returns the 
            correlation function of the full mock galaxy catalog. 

            If using a mask, and if ``include_crosscorr`` is False (the default option), 
            method returns the correlation function of the subsample of galaxies determined by 
            the input mask. 

            If using a mask, and if ``include_crosscorr`` is True, 
            method will return the auto-correlation of the subsample, 
            the cross-correlation of the subsample and the complementary subsample, 
            and the the auto-correlation of the complementary subsample, in that order. 
            See the example below. 

        Notes 
        -----
        The `compute_average_galaxy_matter_cross_clustering` method bound to 
        mock instances is just a convenience wrapper 
        around the `~halotools.mock_observables.clustering.tpcf` function. If you wish for greater 
        control over how your galaxy clustering signal is estimated, 
        see the `~halotools.mock_observables.clustering.tpcf` documentation. 
        """
        if summary_statistic == 'mean':
            summary_func = np.mean 
        else:
            summary_func = np.median

        halocat_kwargs = {}
        if 'simname' in kwargs:
            halocat_kwargs['simname'] = kwargs['simname']
        if 'desired_redshift' in kwargs:
            halocat_kwargs['redshift'] = kwargs['desired_redshift']
        if 'halo_finder' in kwargs:
            halocat_kwargs['halo_finder'] = kwargs['halo_finder']

        snapshot = HaloCatalog(preload_halo_table = True, **halocat_kwargs)

        if 'rbins' in kwargs:
            rbins = kwargs['rbins']
        else:
            rbins = model_defaults.default_rbins

        if 'include_complement' in kwargs.keys():
            include_complement = kwargs['include_complement']
        else:
            include_complement = False

        if include_complement is True:

            xi_coll = np.zeros(
                (len(rbins)-1)*num_iterations*2).reshape(2, num_iterations, len(rbins)-1)

            for i in range(num_iterations):
                self.populate_mock(snapshot = snapshot)
                rbin_centers, xi_coll[0, i, :], xi_coll[1, i, :] = (
                    self.mock.compute_galaxy_matter_cross_clustering(**kwargs)
                    )
            xi_11 = summary_func(xi_coll[0, :], axis=0)
            xi_22 = summary_func(xi_coll[1, :], axis=0)
            return rbin_centers, xi_11, xi_22
        else:

            xi_coll = np.zeros(
                (len(rbins)-1)*num_iterations).reshape(num_iterations, len(rbins)-1)

            for i in range(num_iterations):
                self.populate_mock(snapshot = snapshot)
                rbin_centers, xi_coll[i, :] = self.mock.compute_galaxy_matter_cross_clustering(**kwargs)
            xi = summary_func(xi_coll, axis=0)
            return rbin_centers, xi




class SubhaloModelFactory(ModelFactory):
    """ Class used to build any model of the galaxy-halo connection 
    in which there is a one-to-one correspondence between subhalos and galaxies.  

    Can be thought of as a factory that takes a model blueprint as input, 
    and generates a Subhalo Model object. The returned object can be used directly to 
    populate a simulation with a Monte Carlo realization of the model. 
    """

    def __init__(self, input_model_blueprint, **kwargs):
        """
        Parameters
        ----------
        input_model_blueprint : dict 
            The main dictionary keys of ``input_model_blueprint`` 
            are ``galprop_key`` strings, the names of 
            properties that will be assigned to galaxies 
            e.g., ``stellar_mass``, ``sfr``, ``morphology``, etc. 
            The dictionary value associated with each ``galprop_key``  
            is a class instance of the type of model that 
            maps that property onto subhalos. 

        galprop_sequence : list, optional
            Some model components may have explicit dependence upon 
            the value of some other galaxy model property. A classic 
            example is if the stellar mass of a central galaxy has explicit 
            dependence on whether or not the central is active or quiescent. 
            In such a case, you must pass a list of the galaxy properties 
            of the composite model; the first galprop in ``galprop_sequence`` 
            will be assigned first by the ``mock_factory``; the second galprop 
            in ``galprop_sequence`` will be assigned second, and its computation 
            may depend on the first galprop, and so forth. Default behavior is 
            to assume that no galprop has explicit dependence upon any other. 

        galaxy_selection_func : function object, optional  
            Function object that imposes a cut on the mock galaxies. 
            Function should take an Astropy table as a positional argument, 
            and return a boolean numpy array that will be 
            treated as a mask over the rows of the table. If not None, 
            the mask defined by ``galaxy_selection_func`` will be applied to the 
            ``halo_table`` after the table is generated by the `populate_mock` method. 
            Default is None.  
        """

        super(SubhaloModelFactory, self).__init__(input_model_blueprint, **kwargs)

        self.mock_factory = mock_factories.SubhaloMockFactory

        self.model_blueprint = copy(self._input_model_blueprint)
        
        self._build_composite_lists(**kwargs)

        self._set_init_param_dict()

        self._set_primary_behaviors()

    def _set_primary_behaviors(self):
        """ Creates names and behaviors for the primary methods of `SubhaloModelFactory` 
        that will be used by the outside world.  

        Notes 
        -----
        The new methods created here are given standardized names, 
        for consistent communication with the rest of the package. 
        This consistency is particularly important for mock-making, 
        so that the `SubhaloModelFactory` can always call the same functions 
        regardless of the complexity of the model. 

        The behaviors of the methods created here are defined elsewhere; 
        `_set_primary_behaviors` just creates a symbolic link to those external behaviors. 
        """

        for galprop_key in self.galprop_list:
            
            behavior_name = 'mc_'+galprop_key
            behavior_function = self._update_param_dict_decorator(galprop_key, behavior_name)
            setattr(self, behavior_name, behavior_function)

    def _update_param_dict_decorator(self, galprop_key, func_name):
        """ Decorator used to propagate any possible changes 
        in the composite model param_dict 
        down to the appropriate component model param_dict. 
        """

        component_model = self.model_blueprint[galprop_key]

        def decorated_func(*args, **kwargs):

            # Update the param_dict as necessary
            for key in component_model.param_dict.keys():
                composite_key = galprop_key + '_' + key
                if composite_key in self.param_dict.keys():
                    component_model.param_dict[key] = self.param_dict[composite_key]

            # # Also update the param dict of ancillary models, if applicable
            # if hasattr(component_model, 'ancillary_model_dependencies'):
            #     for model_name in component_model.ancillary_model_dependencies:

            #         dependent_galprop_key = getattr(component_model, model_name).galprop_key
            #         for key in getattr(component_model, model_name).param_dict.keys():
            #             composite_key = composite_key = dependent_galprop_key + '_' + key
            #             if composite_key in self.param_dict.keys():
            #                 getattr(component_model, model_name).param_dict[key] = (
            #                     self.param_dict[composite_key]
            #                     )

            func = getattr(component_model, func_name)
            return func(*args, **kwargs)

        return decorated_func

    def _galprop_func(self, galprop_key):
        """
        """
        component_model = self.model_blueprint[galprop_key]
        behavior_function = getattr(component_model, 'mc_'+galprop_key) 
        return behavior_function

    def _build_composite_lists(self, **kwargs):
        """ A composite model has several bookkeeping devices that are built up from 
        the components: ``_haloprop_list``, ``publications``, and ``new_haloprop_func_dict``. 
        """

        unordered_galprop_list = [key for key in self.model_blueprint.keys()]
        if 'galprop_sequence' in kwargs.keys():
            if set(kwargs['galprop_sequence']) != set(unordered_galprop_list):
                raise KeyError("The input galprop_sequence keyword argument must "
                    "have the same list of galprops as the input model blueprint")
            else:
                self.galprop_list = kwargs['galprop_sequence']
        else:
            self.galprop_list = unordered_galprop_list

        haloprop_list = []
        pub_list = []
        new_haloprop_func_dict = {}

        for galprop in self.galprop_list:
            component_model = self.model_blueprint[galprop]

            # haloprop keys
            if hasattr(component_model, 'prim_haloprop_key'):
                haloprop_list.append(component_model.prim_haloprop_key)
            if hasattr(component_model, 'sec_haloprop_key'):
                haloprop_list.append(component_model.sec_haloprop_key)

            # Reference list
            if hasattr(component_model, 'publications'):
                pub_list.extend(component_model.publications)

            # Haloprop function dictionaries
            if hasattr(component_model, 'new_haloprop_func_dict'):
                dict_intersection = set(new_haloprop_func_dict).intersection(
                    set(component_model.new_haloprop_func_dict))
                if dict_intersection == set():
                    new_haloprop_func_dict = dict(
                        new_haloprop_func_dict.items() + 
                        component_model.new_haloprop_func_dict.items()
                        )
                else:
                    example_repeated_element = list(dict_intersection)[0]
                    raise KeyError("The composite model received multiple "
                        "component models with a new_haloprop_func_dict that use "
                        "the %s key" % example_repeated_element)

        self._haloprop_list = list(set(haloprop_list))
        self.publications = list(set(pub_list))
        self.new_haloprop_func_dict = new_haloprop_func_dict

    def _set_init_param_dict(self):
        """ Method used to build a dictionary of parameters for the composite model. 

        Accomplished by retrieving all the parameters of the component models. 
        Method returns nothing, but binds ``param_dict`` to the class instance. 

        Notes 
        -----
        In MCMC applications, the items of ``param_dict`` define the 
        parameter set explored by the likelihood engine. 
        Changing the values of the parameters in ``param_dict`` 
        will propagate to the behavior of the component models. 

        Each component model has its own ``param_dict`` bound to it. 
        When changing the values of ``param_dict`` bound to `HodModelFactory`, 
        the corresponding values of the component model ``param_dict`` will *not* change.  

        """

        self.param_dict = {}

        # Loop over all galaxy types in the composite model
        for galprop in self.galprop_list:
            galprop_model = self.model_blueprint[galprop]

            if hasattr(galprop_model, 'param_dict'):
                galprop_model_param_dict = (
                    {galprop_model.galprop_key+'_'+key:val for key, val in galprop_model.param_dict.items()}
                    )
            else:
                galprop_model_param_dict = {}

            intersection = set(self.param_dict) & set(galprop_model_param_dict)
            if intersection != set():
                repeated_key = list(intersection)[0]
                raise KeyError("The param_dict key %s appears in more "
                    "than one component model" % repeated_key)
            else:

                self.param_dict = dict(
                    galprop_model_param_dict.items() + 
                    self.param_dict.items()
                    )

        self._init_param_dict = copy(self.param_dict)

    def restore_init_param_dict(self):
        """ Reset all values of the current ``param_dict`` to the values 
        the class was instantiated with. 

        Primary behaviors are reset as well, as this is how the 
        inherited behaviors get bound to the values in ``param_dict``. 
        """
        self.param_dict = self._init_param_dict
        self._set_primary_behaviors()

class HodModelFactory(ModelFactory):
    """ Class used to build HOD-style models of the galaxy-halo connection. 

    Can be thought of as a factory that takes an HOD model blueprint as input, 
    and generates an HOD Model object. The returned object can be used directly to 
    populate a simulation with a Monte Carlo realization of the model. 

    Most behavior is derived from external classes bound up in the input ``model_blueprint``. 
    So the purpose of `HodModelFactory` is mostly to compose these external 
    behaviors together into a composite model. 
    The aim is to provide a standardized model object 
    that interfaces consistently with the rest of the package, 
    regardless of the features of the model. 
    
    """

    def __init__(self, input_model_blueprint, **kwargs):
        """
        Parameters
        ----------
        input_model_blueprint : dict 
            The main dictionary keys of ``input_model_blueprint`` 
            are the names of the types of galaxies 
            found in the halos, 
            e.g., ``centrals``, ``satellites``, ``orphans``, etc. 
            The dictionary value associated with each ``gal_type`` key 
            is itself a dictionary whose keys 
            specify the type of model component, e.g., ``occupation``, 
            and values are class instances of that type of model. 
            The `interpret_input_model_blueprint` translates 
            ``input_model_blueprint`` into ``self.model_blueprint``.
        """

        super(HodModelFactory, self).__init__(input_model_blueprint, **kwargs)

        # Create attributes for galaxy types and their occupation bounds
        self._set_gal_types()
        self.model_blueprint = self._input_model_blueprint

        self._set_model_redshift()

        # Build up and bind several lists from the component models
        self._build_composite_lists()

        # Build the composite model dictionary, 
        # whose keys are parameters of our model
        self._set_init_param_dict()

        # Create a set of bound methods with specific names 
        # that will be called by the mock factory 
        self._set_primary_behaviors()
        self._set_calling_sequence(**kwargs)
        self._test_blueprint_consistency()

        self.mock_factory = mock_factories.HodMockFactory


    def _set_gal_types(self):
        """ Private method binding the ``gal_types`` list attribute. 
        If there are both centrals and satellites, method ensures that centrals 
        will always be built first, out of consideration for satellite 
        model components with explicit dependence on the central population. 
        """
        gal_types = [key for key in self._input_model_blueprint.keys()]

        first = [g for g in gal_types if 'central' in g]
        middle = [g for g in gal_types if 'satellite' in g]
        last = [g for g in gal_types if 'central' not in g and 'satellite' not in g]

        self.gal_types = first 
        self.gal_types.extend(middle)
        self.gal_types.extend(last)

    def _set_primary_behaviors(self):
        """ Creates names and behaviors for the primary methods of `HodModelFactory` 
        that will be used by the outside world.  

        Notes 
        -----
        The new methods created here are given standardized names, 
        for consistent communication with the rest of the package. 
        This consistency is particularly important for mock-making, 
        so that the `HodMockFactory` can always call the same functions 
        regardless of the complexity of the model. 

        The behaviors of the methods created here are defined elsewhere; 
        `_set_primary_behaviors` just creates a symbolic link to those external behaviors. 
        """

        for gal_type in self.gal_types:

            gal_type_blueprint = self.model_blueprint[gal_type]

            feature_generator = (feature_name for feature_name in gal_type_blueprint)

            for feature_name in feature_generator:
                component_model_instance = gal_type_blueprint[feature_name]
                try:
                    component_model_galprop_dtype = component_model_instance._galprop_dtypes_to_allocate
                except AttributeError:
                    component_model_galprop_dtype = np.dtype([])

                methods_to_inherit = list(set(
                    component_model_instance._methods_to_inherit))

                for methodname in methods_to_inherit:
                    new_method_name = methodname + '_' + gal_type
                    new_method_behavior = self._update_param_dict_decorator(
                        component_model_instance, methodname)
                    setattr(self, new_method_name, new_method_behavior)
                    setattr(getattr(self, new_method_name), 
                        '_galprop_dtypes_to_allocate', component_model_galprop_dtype)
                    setattr(getattr(self, new_method_name), 'gal_type', gal_type)

                attrs_to_inherit = list(set(
                    component_model_instance._attrs_to_inherit))
                for attrname in attrs_to_inherit:
                    new_attr_name = attrname + '_' + gal_type
                    attr = getattr(component_model_instance, attrname)
                    setattr(self, new_attr_name, attr)

            # Repeatedly overwrite self.threshold 
            # This is harmless provided that all gal_types are ensured to have the same threshold, 
            # which is guaranteed by the _test_blueprint_consistency method
            self.threshold = getattr(self, 'threshold_' + gal_type)


    def _update_param_dict_decorator(self, component_model, func_name):
        """ Decorator used to propagate any possible changes 
        in the composite model param_dict 
        down to the appropriate component model param_dict. 
        """

        def decorated_func(*args, **kwargs):

            # Update the param_dict as necessary
            for key in self.param_dict.keys():
                if key in component_model.param_dict:
                    component_model.param_dict[key] = self.param_dict[key]

            func = getattr(component_model, func_name)
            return func(*args, **kwargs)

        return decorated_func

    def build_lookup_tables(self):
        """ Method to compute and load lookup tables for each of 
        the phase space component models. 
        """

        for gal_type in self.gal_types:
            profile_model = self.model_blueprint[gal_type]['profile']
            if hasattr(profile_model, 'build_lookup_tables'):
                profile_model.build_lookup_tables()

    def _set_init_param_dict(self):
        """ Method used to build a dictionary of parameters for the composite model. 

        Accomplished by retrieving all the parameters of the component models. 
        Method returns nothing, but binds ``param_dict`` to the class instance. 

        Notes 
        -----
        In MCMC applications, the items of ``param_dict`` define the possible 
        parameter set explored by the likelihood engine. 
        Changing the values of the parameters in ``param_dict`` 
        will propagate to the behavior of the component models 
        when the relevant methods are called. 
        """

        self.param_dict = {}

        try:
            suppress_warning = self._suppress_repeated_param_warning
        except AttributeError:
            suppress_warning = False
        msg = ("\n\nThe param_dict key %s appears in more than one component model.\n"
            "This is permissible, but if you are seeing this message you should be sure you "
            "understand it.\nIn particular, double-check that this parameter does not have "
            "conflicting meanings across components.\n"
            "\nIf you do not wish to see this message every time you instantiate, \n"
            "simply attach a _suppress_repeated_param_warning attribute to any of your component models, \n"
            "and set this variable to ``True``.\n")

        # Loop over all galaxy types in the composite model
        for gal_type in self.gal_types:
            gal_type_dict = self.model_blueprint[gal_type]
            # For each galaxy type, loop over its features
            for model_instance in gal_type_dict.values():

                if not hasattr(model_instance, 'param_dict'):
                    model_instance.param_dict = {}
                intersection = set(self.param_dict) & set(model_instance.param_dict)
                if intersection != set():
                    for key in intersection:
                        if suppress_warning is False:
                            warn(msg % key)

                for key, value in model_instance.param_dict.iteritems():
                    self.param_dict[key] = value

        self._init_param_dict = copy(self.param_dict)

    def restore_init_param_dict(self):
        """ Reset all values of the current ``param_dict`` to the values 
        the class was instantiated with. 

        Primary behaviors are reset as well, as this is how the 
        inherited behaviors get bound to the values in ``param_dict``. 
        """
        self.param_dict = self._init_param_dict
        self._set_primary_behaviors()

    def _set_model_redshift(self):
        """ 
        """
        msg = ("Inconsistency between the redshifts of the component models:\n"
            "    For gal_type = ``%s``, the %s model has redshift = %.2f.\n"
            "    For gal_type = ``%s``, the %s model has redshift = %.2f.\n")

        for gal_type in self.gal_types:
            component_dict = self.model_blueprint[gal_type]
            for component_key in component_dict.keys():
                component_model = component_dict[component_key]

                if hasattr(component_model, 'redshift'):
                    redshift = component_model.redshift 
                    try:
                        if redshift != existing_redshift:
                            t = (gal_type, component_model.__class__.__name__, redshift, 
                                last_gal_type, last_component.__class__.__name__, existing_redshift)
                            raise HalotoolsError(msg % t)
                    except NameError:
                        existing_redshift = redshift 

                last_component = component_model
                last_gal_type = gal_type

        self.redshift = redshift

    def _build_composite_lists(self):
        """ A composite model has several lists that are built up from 
        the components: ``_haloprop_list``, ``publications``, and 
        ``new_haloprop_func_dict``. 
        """

        haloprop_list = []
        prof_param_keys = []
        pub_list = []
        dtype_list = []
        new_haloprop_func_dict = {}
        self._suppress_repeated_param_warning = False

        for gal_type in self.gal_types:
            component_dict = self.model_blueprint[gal_type]
            for component_key in component_dict.keys():
                component_model = component_dict[component_key]

                # haloprop keys
                if hasattr(component_model, 'prim_haloprop_key'):
                    haloprop_list.append(component_model.prim_haloprop_key)
                if hasattr(component_model, 'sec_haloprop_key'):
                    haloprop_list.append(component_model.sec_haloprop_key)

                # halo profile parameter keys
                if hasattr(component_model, 'prof_param_keys'):
                    prof_param_keys.extend(component_model.prof_param_keys)

                # Column dtypes to add to mock galaxy_table
                if hasattr(component_model, '_galprop_dtypes_to_allocate'):
                    dtype_list.append(component_model._galprop_dtypes_to_allocate)

                # Reference list
                if hasattr(component_model, 'publications'):
                    pub_list.extend(component_model.publications)

                # Warning suppressions 
                if hasattr(component_model, '_suppress_repeated_param_warning'):
                    self._suppress_repeated_param_warning += component_model._suppress_repeated_param_warning

                # Haloprop function dictionaries
                if hasattr(component_model, 'new_haloprop_func_dict'):
                    dict_intersection = set(new_haloprop_func_dict).intersection(
                        set(component_model.new_haloprop_func_dict))
                    if dict_intersection == set():
                        new_haloprop_func_dict = dict(
                            new_haloprop_func_dict.items() + 
                            component_model.new_haloprop_func_dict.items()
                            )
                    else:
                        example_repeated_element = list(dict_intersection)[0]
                        msg = ("The composite model received multiple "
                            "component models \nwith a new_haloprop_func_dict that use "
                            "the %s key. \nIgnoring the one that appears in the %s " 
                            "component for %s galaxies")
                        warn(msg % (example_repeated_element, component_key, gal_type))

                # Ensure that all methods in the calling sequence are inherited
                try:
                    mock_making_methods = component_model._mock_generation_calling_sequence
                except AttributeError:
                    mock_making_methods = []
                try:
                    inherited_methods = component_model._methods_to_inherit
                except AttributeError:
                    inherited_methods = []
                    component_model._methods_to_inherit = []

                missing_methods = set(mock_making_methods) - set(inherited_methods).intersection(set(mock_making_methods))
                for methodname in missing_methods:
                    component_model._methods_to_inherit.append(methodname)

                if not hasattr(component_model, '_attrs_to_inherit'):
                    component_model._attrs_to_inherit = []


        self._haloprop_list = list(set(haloprop_list))
        self.prof_param_keys = list(set(prof_param_keys))
        self.publications = list(set(pub_list))
        self.new_haloprop_func_dict = new_haloprop_func_dict
        self._galprop_dtypes_to_allocate = model_helpers.create_composite_dtype(dtype_list)
        self._suppress_repeated_param_warning = bool(self._suppress_repeated_param_warning)

    def _set_calling_sequence(self, **kwargs):
        """
        """
        self._mock_generation_calling_sequence = []

        missing_calling_sequence_msg = ("\nComponent models typically have a list attribute called "
            "_mock_generation_calling_sequence.\nThis list determines the methods that are called "
            "by the mock factory, and the order in which they are called.\n"
            "The ``%s`` component of the gal_type = ``%s`` population has no such method.\n"
            "Only ignore this warning if you are sure this is not an error.\n")

        ###############
        # If provided, retrieve the input list of tuples defining the calling sequence.
        # Otherwise, build the tuple list according to the default calling sequence
        if 'mock_generation_calling_sequence' in kwargs:
            sequence_tuples = kwargs['mock_generation_calling_sequence']
        else:
            sequence_tuples = []
            feature_keys = self.model_blueprint[self.model_blueprint.keys()[0]].keys()
            feature_keys.remove('occupation')
            feature_keys.remove('profile')
            feature_keys.insert(0, 'occupation')
            feature_keys.append('profile')
            for feature_key in feature_keys:
                for gal_type in self.gal_types:
                    sequence_tuples.append((gal_type, feature_key))

        ###############
        # Loop over the list of tuples and successively append 
        # each component model's calling sequence to the composite model calling sequence
        for component_model_tuple in sequence_tuples:
            gal_type = component_model_tuple[0]
            feature_key = component_model_tuple[1]
            component_model = self.model_blueprint[gal_type][feature_key]
            if hasattr(component_model, '_mock_generation_calling_sequence'):
                component_method_list = (
                    [name + '_' + gal_type 
                    for name in component_model._mock_generation_calling_sequence]
                    )
                self._mock_generation_calling_sequence.extend(component_method_list)
            else:
                warn(missing_calling_sequence_msg % (feature_key, gal_type))


    def _test_blueprint_consistency(self):
        """
        Impose the following requirements on the blueprint: 

            * All occupation components have the same threshold. 

            * Each element in _mock_generation_calling_sequence is included in _methods_to_inherit
        """
        threshold_list = [getattr(self, 'threshold_' + gal_type) for gal_type in self.gal_types]
        if len(threshold_list) > 1:
            d = np.diff(threshold_list)
            if np.any(d != 0):
                threshold_msg = ''
                for gal_type in self.gal_types:
                    threshold_msg += '\n' + gal_type + ' threshold = ' + str(getattr(self, 'threshold_' + gal_type))
                msg = ("Inconsistency in the threshold of the component occupation models:\n" + threshold_msg + "\n")
                raise HalotoolsError(msg)

        missing_method_msg1 = ("\nAll component models have a ``_mock_generation_calling_sequence`` attribute,\n"
            "which is a list of method names that are called by the ``populate_mock`` method of the mock factory.\n"
            "All component models also have a ``_methods_to_inherit`` attribute, \n"
            "which determines which methods of the component model are inherited by the composite model.\n"
            "The former must be a subset of the latter. However, for ``gal_type`` = %s,\n"
            "the following method was not inherited:\n%s")
        for gal_type in self.gal_types:
            for component_model in self.model_blueprint[gal_type].values():
                mock_generation_methods = set(component_model._mock_generation_calling_sequence)
                inherited_methods = set(component_model._methods_to_inherit)
                overlap = mock_generation_methods.intersection(inherited_methods)
                missing_methods = mock_generation_methods - overlap
                if missing_methods != set():
                    some_missing_method = list(missing_methods)[0]
                    raise HalotoolsError(missing_method_msg1 % (gal_type, some_missing_method))

        missing_method_msg2 = ("\nAll component models have a ``_mock_generation_calling_sequence`` attribute,\n"
            "which is a list of method names that are called by the ``populate_mock`` method of the mock factory.\n"
            "The HodModelFactory builds a composite ``_mock_generation_calling_sequence`` from each of these lists.\n"
            "However, the following method does not appear to have been created during this process:\n%s\n"
            "This is likely a bug in Halotools - please raise an Issue on https://github.com/astropy/halotools\n")
        for method in self._mock_generation_calling_sequence:
            if not hasattr(self, method):
                raise HalotoolsError(missing_method_msg2)

##########################################





















